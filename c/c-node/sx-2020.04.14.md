## 半圆笔记 04.14

**总结三种基本排序算法的思路和步骤（包括用数组实现和用链表实现）**

**插入排序**

数组实现

```c
// 第一步 数组的第一位先暂时放在a[0]
// 第二步 创建一个临时变量temp 用来保存a[i]的值
// 第三步 判断temp=a[1]的值与a[0]的值得大小，如果a[1]>a[0],则位置不变，如果a[1]<a[0],则将a[0]的值赋值给a[1],再将a[i]（实际上在这一步就是a[1]的值赋值给a[0]）
// 第四步 判断temp=a[2]的值与a[1]的值得大小，如果a[2]>a[1],则位置不变，如果a[2]<a[1],则将a[1]的值赋值给a[2],在判断temp与a[0]的大小，如果temp>a[0]，则将temp赋值给a[1],如果temp<a[0]，则将a[0]赋值给a[1],temp赋值给a[0]
// 重复三四步的操作一直到i = n-1。
// 得到有序数组
// 关键代码
for (int i = 1; i < n; i++) {
        int j = i - 1;
        int temp = a[i];
        while (j >= 0 && a[j] > temp) {
            a[j + 1] = a[j];
            j--;
        }
        a[j + 1] = temp;
```

链表实现

```c
// 第一步 得到一个链表 一个指向链表首节点的head，有一个指针end* end指向排好序的尾结点。
// 第二步 判断第二个结点的elem2与首节点的elem1的大小，如果elem2>elem1 则不变，如果elem2<elem1,则 head->Node2 Node1->next = Node2->next Node2->next = Node1
// 第三步 假设一直上面的是前小于后，直到第k个结点Node *k，此时end指向（k-1）结点
      
// 第四步 假设为temp*指向首节点，判断首节点的值与k的值得大小如果k->elem > temp->elem 则temp = temp->next 在进行比较，直到找到一个位置，假设为x k应该在x的前面 x-1的后面，先将end节点与k后面的结点连接 然后把k结点和这两个结点建立连接

//每次都可以通过end来找到需要排序的结点
//重复操作

```



**选择排序**

数组实现

```c
// 遍历第一次，找到最小值，设置一个临时的变量temp temp = a[0] a[0] = a [k] a[k] = temp ，完成数值的互换
// 遍历第二次，找到最小值，temp = a[1] a[1] = a[p] a[p] = temp 。
// 以此类推，找到每次遍历的最小值。放的第i个位置上
// 找到最小值的思路 假设最小值a[min] = a[i],如果后面有比a[i]值小的 那么 min = i+k  就可以找到下标 k 和 p 
```

链表实现

```c
// 创建一个 整数temp 和指针temp*
// 第一步 假设 temp = head->next->elem temp = head->next
// 第二步 判断下一个节点的值与temp的大小 如果temp小，则往后判断，如果某一节点的elem比temp小 则temp = 这个elem temp指针指向这个节点 在接着往后判断，直到NULL，可以得到最小的值temp 和这个节点的位置temp 。
// 第三步 把这个节点的值和首节点的值互换 
// 重复一到三步骤， 在从第二个节点开始 替换最小值 直到最后的结点
```



**冒泡排序**

数组实现

```c
// 第一步 0和1位置比较大小，如需交换位置，大的放在后面
// 第二步 1和2位置比较大小，如需交换位置，大的放在后面
// 第三步 重复操作直到n-1和n,算作一次冒泡
// 第四步 重复一到三步，重复操作到n-i-1和n-i
// 如果某次冒泡，顺序一直没有发生过置换，则结束(首先在外部假设一个变量等于0 在交换的循环里令这个变量等于1，如果交换一直没有执行，则这个变量是0,那么就结束)
```

链表实现

```c
// head指向第一个节点 判断head->elem与head->next->elem的大小 如果需要的话将这两个值进行互换，head = head->next 在进行判断与值得互换 i = 0 i++ i<n时继续进行
// head指向第一个结点 重复第一步的操作，i= 0 i++ i < n-1时继续操作
// 重复 
// 直到每一项冒泡完毕
```