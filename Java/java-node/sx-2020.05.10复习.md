## 类的继承

1、**类的继承**

使用extends 一个类来继承类 可以继承类里除private以外的成员和方法，如果不是同包路径，不写的方法和成员也无法继承，继承无法继承构造方法，父类只有无参数的构造方法是，子类成员构造方法可以不写，默认调用父类的构造方法；在父类有有参数的构造方法时，系统不会给父类一个无参数的构造方法，子类使用父类的构造方法可以使用super();同理 在子类里调用父类的方法也是一样的。

2、**方法重写**

方法名和参数类型相同，修改权限修饰符 修改返回值(返回值的类是父类的子类才可以 ) 修改方法实现 称之为方法的重写。注意权限修饰符只能改大不能改小。其他都不变 只修改方法的实现 称之为重构。返回值修改(不是父子类关系)，参数个数 类型改变 称之为重载。

1. 子类不能重写父类的private方法

2. 重写的方法名和参数列表必须与父类中完全相同

3. 重写的方法的访问修饰符不小于父类被重写方法的访问修饰符

4. 返回值

   - 父类方法是void或基本数据类型，子类重写的方法必须和父类方法保持一致
   - 父类方法是类A的对象，那么子类重写的方法必须是类A的对象或类A子类的对象

   - @Override 

3、**父子类的实例化**

在实例化子类的时候，在子类内部会有一部分区域，先实例化父类。

父类--静态变量 
父类--静态初始化块 
子类--静态变量 
子类--静态初始化块 
父类--变量 
父类--初始化块 
父类--构造器 
子类--变量 
子类--初始化块 
子类--构造器 

先执行静态变量和静态代码块，在类加载的时候即初始化，但是只会加载一次 后面再new对象的时候不会加载。

随后会先构造父类对象，先初始化变量和非静态代码块，在初始化子类的变量和非静态代码块。

4、**父类的访问修饰符**

子类具备了父类定义的所有成员和方法，但是是否可以访问这些成员和方法，要根据父类中对成员和方法的访问修饰符来决定

- **protect**

​      子类继承的父类`protect`方法和成员仅能在和父类同包的内中使用或者子类内部使用。子类可以和父类同包也可以不同包 不同包的内部也可以调用protected方法 但是在其他类里就不能用了

1. 子类和父类在同一个包下或不同包下，子类内部都可以访问到父类中`protected`的成员和方法
2. 子类和父类在同一个包下，其他类不在同一个包下，那么其他类中不能访问这些成员和方法
3. 子类和父类不再同一个包下，其他类如果和父类同包，则可以通过子类或父类对象访问`protected`成员和方法。如果其他类和父类不同包，即便和子类同包，也不能通过子类或父类独享访问这些成员和方法。

- **private**

1. 子类内部不能访问父类的私有成员和方法，其他类就更不可能访问到这些成员和方法
2. 如果父类的外部方法（public protected）访问其`private`属性或方法，子类可以通过调用这些方法间接访问这些`private`属性或方法

- **不写**

1. 子类和父类在同一个包下，子类内部可以访问到父类默认权限的成员和方法，其他类如果也在同一个包下，则其他类可以通过子类或父类对象访问到这些成员和方法。
2. 子类和父类在同一个包下，其他类不在同一个包下，那么其他类中不能访问这些成员和方法
3. 子类和父类不再同一个包下，子类内部也访问不到默认权限的属性和方法，其他类无论在什么包下面，也不能通过子类来访问这些属性和方法

## 对象类型的转换

1、**向上转型**

子类对象可以使用父类 类名 + 对象名的来引用

```
class A {
         public void print() {
                  System.out.println("A:print");
         }
}

class B extends A {
         public void print() {        
                  System.out.println("B:print");
         }
}

public class Test{
         public static void main(String args[])
         {
                  A a = new B();         
                  a.print();
         }
}
```

如上所示 A a = new B ()，称之为向上转型，此时a可以调用a里有的属性和方法 ，不能调用b里非继承来的方法 同时 由于a实际上保存的是B的对象，所以在实现a.print()方法时 ，会实现被重写的方法 注意如果子类里面的访问权限修饰符修改变小了，则会报错 因为重写的访问权限修饰符纸只能变大不能变小。如果是静态方法 则看前面的类型是什么就调用哪个静态方法。

2、**向下转型**

在程序中，如果需要将父类的对象转换成子类 必须使用强制类型转换，

 B b = (B) a;

但是在这个强制转换的过程中，如果a并不是B的一个实例 就会产生ClassCastException异常 所以在转换的过程中 我们需要在转换前先判断其是否是需要转换的类的实例 使用instanceof 方法 `a instanceof B`返回值为boolean 类型 后面也可以用来判断是否实现了一个接口。



## 方法的重载

1、方法的返回类型不同 不构成方法的重载 会报错 方法的重载是在同一个类中允许存在一个以上的同名方法，只要将这些放法的参数个数或者类型不通即可。方法的重载等于是给人重新的选择 而方法的重写相当于是覆盖。



## 多态

1、多台存在的三个必要条件   继承 重写 父类引用指向子类对象

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。

多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。

不能表现多态性的情况：

- static方法 ，被static修饰的方法是属于类的，而不是属于实例的
- final 方法，因为被final修饰的方法无法被子类重写
- private方法和protect方法和不写的方法 private 方法对子类不可见 相当于无法继承 子类写的和父类同名的方法相当于是他自己的方法 ，而protect修饰的和不写的 虽然子类可以重写(如果是不写的话 且子类和父类不是一个包路径 也不构成重写) 但是外部的类无法调用 不谈多态性,虽然在一个包路径下运行起来还是按照多态性那样；



## 抽象类和接口

1、**抽象类**

父类不需要实例化 可以定义为抽象类 但是抽象类中可以定义构造方法，以便在初始化其子类对象时，对成员变量进行初始化，可以使用protect来修饰构造方法 因为用public 没有实际的意义；使用`abatract`修饰的类被称为抽象类 修饰的方法称为抽象方法 而含有抽象方法的类一定是抽象类 在抽象类内部 允许使用抽象方法 没有方法体 子类必须重写 否则会编译报错

2、**接口**

解决Java无法继承多个类的问题

接口是抽象类的延伸，可以将其看作是纯粹的抽象类 接口中的方法均没有方法体 接口中只有常量而没有变量 也不会有构造函数 ，接口类中的方法默认都是 public abstract 的 可以使用default 来修饰方法 这样就可以写方法体的方法了

3、实现接口使用implements 后面用逗号隔开 

4、

接口和差异点

- 接口里面包含抽象方法和默认方法，抽象类里面包含抽象方法和普通方法
- 接口里只能定义常量属性，抽象类里可以定义任意属性，常量、私有、静态
- 接口没有构造方法，抽象类里可以提供构造方法指导子类初始化抽象类提供的属性
- 一个类可以实现多个接口，但只能继承一个类包括抽象类

## final

1、final 变量 final关键字可用于变量声明 如果该变量被赋值，就不能在改变该变量的值；

2、final 修饰数组 意味该数组引用不能在指向其他的数组地址，但是其数组内部的值还是可以修改的；

3、final 修饰的方法不能被重写；

4、final定义的类不能被继承；